package com.ericgha.docuCloud.repository.testutil.file;

import com.ericgha.docuCloud.jooq.tables.records.FileRecord;
import com.ericgha.docuCloud.jooq.tables.records.FileViewRecord;
import com.ericgha.docuCloud.jooq.tables.records.TreeRecord;
import com.ericgha.docuCloud.repository.testutil.tree.TestFileTree;
import lombok.NonNull;

import java.util.Comparator;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TestFiles {

    private final TestFileTree tree;
    private final FileTestQueries fileQueries;
    // this isn't really used but the size field of each new file is an autoincrementing long
    private final Comparator<TreeRecord> treeRecordComp;
    private final Comparator<FileViewRecord> fileViewRecordComp;
    private long fileSize = 0;

    // keys are file checksums
    private final NavigableMap<String, NavigableSet<FileViewRecord>> fileViewRecordByObjectPath;
    private final NavigableMap<String, NavigableSet<TreeRecord>> treeRecordByFileChecksum;

    public TestFiles(TestFileTree tree, FileTestQueries fileQueries,
                     Comparator<TreeRecord> treeRecordComp, Comparator<FileViewRecord> fileViewRecordComp) {
        this.tree = tree;
        this.fileQueries = fileQueries;
        this.treeRecordComp = treeRecordComp;
        this.fileViewRecordComp = fileViewRecordComp;
        fileViewRecordByObjectPath = new TreeMap<>();
        treeRecordByFileChecksum = new TreeMap<>();
    }

    // If file doesn't exist it is created, if file does exist a link is made
    // In the csv the checksum field in file_view is used as a human friendly file key
    public NavigableSet<FileViewRecord> createFileViewRecords(String csv) {
        return TestFilesCsvParser.parse( csv )
                .map(csvRecord ->  this.createFileViewRecord( csvRecord.treePath(), csvRecord.fileChecksum() ) )
                .collect( Collectors.toCollection(
                        () -> new TreeSet<FileViewRecord>( fileViewRecordComp ) )
                );
    }

    public FileViewRecord createFileViewRecord(String pathStr, String checksum) {
         ObjectFileLink link = this.insertFileViewRecord( pathStr, checksum );
         this.recordNewFileViewRecord( link );
         return link.fileViewRecord();
    }

    // throws if no files are linked to given path
    public NavigableSet<FileViewRecord> getCreatedFileViewRecordsForObject(String pathStr ) throws IllegalArgumentException {
        var records = fileViewRecordByObjectPath.get(pathStr);
        if (Objects.isNull(records) ) {
            throw new IllegalArgumentException("No objects at specified path are linked to any objects created by this instance");
        }
        return records;
    }

    public NavigableSet<TreeRecord> getCreatedObjectsForFile(String fileChecksum ) throws IllegalArgumentException {
        var records = treeRecordByFileChecksum.get(fileChecksum);
        if (Objects.isNull(records) ) {
            throw new IllegalArgumentException("No files with the provided checksum are linked to any objects created by this instance");
        }
        return records;
    }

    public NavigableMap<String, NavigableSet<FileViewRecord>> getCreatedFileViewRecordsGroupedByObjectPath() {
        NavigableMap<String, NavigableSet<FileViewRecord>> copy = new TreeMap<>();
        fileViewRecordByObjectPath.forEach( (key, set) -> {
            set.stream().map( fvr -> fvr.into(FileViewRecord.class) )
        } );

        return

    }

    // map where keys are checksums and values are sets of TreeRecords currently linked to (file with) checksum
    // if multiple fileIds have the same checksum this will break, but very unlikely as fileId (UUIDs) are being autogenerated
    public NavigableMap<String, NavigableSet<TreeRecord>> fetchTreeRecordsGroupedByLinkedFileChecksum() {
        NavigableMap<String, NavigableSet<TreeRecord>> current = new TreeMap<>();
        fetchUserFileViewRecords().forEach( fvr -> {
            String checksum = fvr.getChecksum();
            TreeRecord linkedObj = tree.fetchCurRecord( fvr.getObjectId() );
            NavigableSet<TreeRecord> checksumTreeRecords = current.computeIfAbsent(
                    checksum, k -> new TreeSet<TreeRecord>( treeRecordComp ) );
            checksumTreeRecords.add( linkedObj );
        } );
        return current;
    }


    // records sorted by fileViewRecordComp provided in constructor
    public NavigableSet<FileViewRecord> fetchUserFileViewRecords() {
        UUID userId = tree.getUserId();
        return fileQueries.fetchRecordsByUserId( userId, fileViewRecordComp )
                .collect( () -> new TreeSet<FileViewRecord>( fileViewRecordComp ), TreeSet::add )
                .block();
    }

    // records sorted by treeRecordComp provided in constructor
    public NavigableSet<TreeRecord> fetchObjectsLinkedTo(String checksum) {
        return fileQueries.fetchRecordsByChecksum( checksum, tree.getUserId() )
                .map( fvr -> Objects.requireNonNull( tree.fetchCurRecord( fvr.getObjectId() ), "Failure fetching tree record" ) )
                .sort( treeRecordComp )
                .collect( () -> new TreeSet<TreeRecord>( treeRecordComp ), TreeSet::add )
                .block();
    }

    // records sorted by treeRecordComp provided in constructor
    public NavigableSet<TreeRecord> fetchObjectsLinkedTo(UUID fileId) {
        return fileQueries.fetchRecordsByFileId( fileId, tree.getUserId() )
                .map( fvr -> Objects.requireNonNull( tree.fetchCurRecord( fvr.getObjectId() ), "Failure fetching tree record" ) )
                .collect( () -> new TreeSet<TreeRecord>( treeRecordComp ), TreeSet::add )
                .block();
    }

    public NavigableSet<FileViewRecord> fetchFileViewRecordsLinkedTo(String treePathStr) {
        TreeRecord treeRecord = tree.fetchByObjectPath( treePathStr );
        return fetchFileViewRecordsLinkedTo( treeRecord );

    }

    // uses objectId from treeRecord, does not consider path, userId pulled from tree provided to constructor
    public NavigableSet<FileViewRecord> fetchFileViewRecordsLinkedTo(TreeRecord treeRecord) {
        return fileQueries.fetchRecordsByObjectId( treeRecord.getObjectId() )
                .collect( () -> new TreeSet<FileViewRecord>( fileViewRecordComp ), TreeSet::add )
                .block();
    }

    // only parses fileId from fileRecord, ie does not use checksum
    public NavigableSet<TreeRecord> fetchObjectsLinkedTo(FileRecord fileViewRecord) {
        return fetchObjectsLinkedTo( fileViewRecord.getFileId() );
    }

    ObjectFileLink insertFileViewRecord(String treePath, String checksum) {
        TreeRecord treeRecord = Objects.requireNonNull( tree.getOrigRecord( treePath ), "treePath not found" );
        UUID objectId = treeRecord.getObjectId();
        UUID userId = treeRecord.getUserId();
        FileViewRecord toCreate = new FileViewRecord().setObjectId( objectId )
                .setFileId( UUID.randomUUID() )
                .setUserId( userId );
        FileViewRecord createdRecord;
        if (treeRecordByFileChecksum.containsKey( checksum )) {
            // if duplicate objectPath <-> checksum link, table constraints prevent insertion
            // (unique composite key constraint on tree_join_file)
            createdRecord = fileQueries.createLink( toCreate )
                    .flatMap( rec -> fileQueries.fetchFileViewRecord( rec.getObjectId(), rec.getFileId() ) )
                    .block();
        } else {
            // create new file with link
            toCreate.setChecksum( checksum )
                    .setSize( fileSize++ );
            createdRecord = fileQueries.createFileWithLinks( toCreate ).block();
        }
        return new ObjectFileLink( treeRecord, createdRecord );
    }

    // fileViewRecord => newly created file or link
    // treeRecord => object being linked to file
    void recordNewFileViewRecord(ObjectFileLink link) {
        FileViewRecord fileViewRecord = link.fileViewRecord();
        TreeRecord treeRecord = link.treeRecord();
        String treePath = treeRecord.getPath().data();
        String checksum = fileViewRecord.getChecksum();
        NavigableSet<FileViewRecord> fileRecSet = fileViewRecordByObjectPath.computeIfAbsent(
                treePath, k -> new TreeSet<FileViewRecord>( fileViewRecordComp ) );
        NavigableSet<TreeRecord> treeRecSet = treeRecordByFileChecksum.computeIfAbsent(
                checksum, k -> new TreeSet<TreeRecord>( treeRecordComp ) );
        fileRecSet.add( fileViewRecord );
        treeRecSet.add( treeRecord );
    }

    ObjectFileLink createLinkOrFile(CsvRecord csvRecord) {
        String treePath = csvRecord.treePath();
        String checksum = csvRecord.fileChecksum();
        return this.insertFileViewRecord( treePath, checksum );
    }

    // using ObjectId in fileViewRecord fetches obj path
    String fetchObjectPath(FileViewRecord fileViewRecord) {
        return Objects.requireNonNull( tree.fetchCurRecord( fileViewRecord.getObjectId() ),
                        "TreeRecord does not exist for objectId" )
                .getPath()
                .data();
    }

    private record ObjectFileLink(TreeRecord treeRecord, FileViewRecord fileViewRecord) {
    }

    private record CsvRecord(String treePath, String fileChecksum) {
    }

    static class TestFilesCsvParser {

        private TestFilesCsvParser() throws IllegalAccessException {
            throw new IllegalAccessException("Do not instantiate -- utility class");

        }
        static private final String COMMENT_REGEX = "^\s*#.*";
        static private final String DELIM_REGEX = "\s*,\s*";

        static Stream<CsvRecord> parse(@NonNull String csv) {
            return csv.lines().map( TestFilesCsvParser::splitLine )
                    .filter( split -> split.length == 2 )
                    .map( TestFilesCsvParser::toCsvRecord );
        }

        // returns String[0] for comments else String[2]
        private static String[] splitLine(String line) throws IllegalStateException {
            if (line.matches( COMMENT_REGEX ) || line.isBlank()) {
                // a comment;
                return new String[0];
            }
            String[] split = line.strip()
                    .split( DELIM_REGEX );
            if (split.length != 2) {
                throw new IllegalArgumentException( "Unable to parse line: " + line );
            }
            return split;
        }

        private static CsvRecord toCsvRecord(String[] split) {
            return new CsvRecord( split[0], split[1] );
        }
    }
}
