package com.ericgha.docuCloud.repository.testutil.file;

import com.ericgha.docuCloud.dto.FileDto;
import com.ericgha.docuCloud.dto.FileViewDto;
import com.ericgha.docuCloud.dto.TreeDto;
import com.ericgha.docuCloud.jooq.tables.records.FileRecord;
import com.ericgha.docuCloud.repository.testutil.tree.TestFileTree;
import lombok.NonNull;
import org.springframework.core.convert.converter.Converter;
import reactor.core.scheduler.Scheduler;
import reactor.core.scheduler.Schedulers;

import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TestFiles {

    private final TestFileTree tree;
    private final FileTestQueries fileQueries;
    // this isn't really used but the size field of each new file is an autoincrementing long
    private final Converter<FileViewDto, FileDto> fileViewToFile;
    private long fileSize = 0;

    // keys are file checksums
    private final NavigableMap<String, NavigableSet<FileViewDto>> fileViewDtoByObjectPath;
    private final NavigableMap<String, NavigableSet<TreeDto>> treeDtoByChecksum;
    private final NavigableMap<String, FileDto> fileDtoByChecksum;

    private final Scheduler blockingSched = Schedulers.newBoundedElastic( 1, 100_000, "blocking-task-scheduler" );

    public TestFiles(TestFileTree tree, FileTestQueries fileQueries, Converter<FileViewDto, FileDto> fileViewToFile ) {
        this.tree = tree;
        this.fileQueries = fileQueries;
        this.fileViewToFile = fileViewToFile;
        fileViewDtoByObjectPath = new TreeMap<>();
        treeDtoByChecksum = new TreeMap<>();
        fileDtoByChecksum = new TreeMap<>();
    }

    // If file doesn't exist it is created, if file does exist a link is made
    // In the csv the checksum field in file_view is used as a human friendly file key
    public NavigableSet<FileViewDto> insertFileViewRecords(String csv) {
        return TestFilesCsvParser.parse( csv )
                .map(csvRecord ->  this.insertFileViewRecord( csvRecord.treePath(), csvRecord.fileChecksum() ) )
                .collect( Collectors.toCollection(
                        TreeSet::new )
                );
    }

    public FileViewDto insertFileViewRecord(String pathStr, String checksum) {
         ObjectFileLink link = this.insertFileViewDto( pathStr, checksum );
         this.recordNewFileViewDto( link );
         return link.fileViewDto();
    }

    // throws if no files are linked to given path
    public NavigableSet<FileViewDto> getOrigFileViewsFor(String pathStr ) throws IllegalArgumentException {
        var records = fileViewDtoByObjectPath.get(pathStr);
        if (Objects.isNull(records) ) {
            throw new IllegalArgumentException("No objects at specified path are linked to any objects created by this instance");
        }
        return new TreeSet<>(records);
    }

    public NavigableSet<TreeDto> getOrigTreeObjectsFor(String fileChecksum ) throws IllegalArgumentException {
        var records = treeDtoByChecksum.get(fileChecksum);
        if (Objects.isNull(records) ) {
            throw new IllegalArgumentException("No files with the provided checksum are linked to any objects created by this instance");
        }
        return new TreeSet<>(records);
    }

    public FileDto getOrigFileFor(String checksum) {
        var dto = fileDtoByChecksum.get(checksum);
        if (Objects.isNull( dto ) ) {
            throw new IllegalArgumentException(String.format("No record was created with the checksum: %s", checksum) );
        }
        return dto;
    }

    public NavigableMap<String, NavigableSet<FileViewDto>> getOrigFileViewsGroupedByPath() {
        NavigableMap<String, NavigableSet<FileViewDto>> copy = new TreeMap<>();
        fileViewDtoByObjectPath.keySet().forEach( pathStr ->
            copy.put(pathStr, this.getOrigFileViewsFor(pathStr) )
        );
        return copy;
    }

    public NavigableMap<String, NavigableSet<TreeDto>> getLinkedTreeObjectsByChecksum() {
        NavigableMap<String, NavigableSet<TreeDto>> copy = new TreeMap<>();
        treeDtoByChecksum.keySet().forEach( checksum ->
            copy.put(checksum, this.getOrigTreeObjectsFor( checksum ) )
        );
        return copy;
    }

    // map where keys are checksums and values are sets of TreeDtos currently linked to (file with) checksum
    // if multiple fileIds have the same checksum this will break, but very unlikely as fileId (UUIDs) are being autogenerated
    public NavigableMap<String, NavigableSet<TreeDto>> fetchTreeDtosGroupedByLinkedFileChecksum() {
        NavigableMap<String, NavigableSet<TreeDto>> current = new TreeMap<>();
        fetchUserFileViewDtos().forEach( fvr -> {
            String checksum = fvr.getChecksum();
            TreeDto linkedObj = tree.fetchCurRecord( fvr.getObjectId() );
            NavigableSet<TreeDto> checksumTreeDtos = current.computeIfAbsent(
                    checksum, k -> new TreeSet<TreeDto>() );
            checksumTreeDtos.add( linkedObj );
        } );
        return current;
    }


    // records sorted by fileViewDtoComp provided in constructor
    public NavigableSet<FileViewDto> fetchUserFileViewDtos() {
        UUID userId = tree.getUserId();
        return fileQueries.fetchRecordsByUserId( userId )
                .collect( () -> new TreeSet<FileViewDto>( ), TreeSet::add )
                .block();
    }

    // records sorted by treeDtoComp provided in constructor
    public NavigableSet<TreeDto> fetchObjectsLinkedTo(String checksum) {
        return fileQueries.fetchRecordsByChecksum( checksum, tree.getUserId() )
                .publishOn( blockingSched )
                .map( fvr -> Objects.requireNonNull( tree.fetchCurRecord( fvr.getObjectId() ), "Failure fetching tree record" ) )
                .sort( )
                .collect( () -> new TreeSet<TreeDto>(), TreeSet::add )
                .block();
    }

    // records sorted by treeDtoComp provided in constructor
    public NavigableSet<TreeDto> fetchObjectsLinkedTo(UUID fileId) {
        return fileQueries.fetchRecordsByFileId( fileId, tree.getUserId() )
                .publishOn( blockingSched )
                .map( fvr -> Objects.requireNonNull( tree.fetchCurRecord( fvr.getObjectId() ), "Failure fetching tree record" ) )
                .collect( () -> new TreeSet<TreeDto>( ), TreeSet::add )
                .block();
    }

    public NavigableSet<FileDto> fetchFileDtosLinkedTo(String treePathStr) {
        TreeDto treeDto = tree.fetchByObjectPath( treePathStr );
        return fetchFileDtosLinkedTo( treeDto );

    }

    // uses objectId from treeDto, does not consider path, userId pulled from tree provided to constructor
    public NavigableSet<FileDto> fetchFileDtosLinkedTo(TreeDto treeDto) {
        return fileQueries.fetchRecordsByObjectId( treeDto.getObjectId() )
                .map( fileViewToFile::convert )
                .collect( () -> new TreeSet<FileDto>( ), TreeSet::add )
                .block();
    }

    // only parses fileId from fileRecord, ie does not use checksum
    public NavigableSet<TreeDto> fetchObjectsLinkedTo(FileRecord fileViewDto) {
        return fetchObjectsLinkedTo( fileViewDto.getFileId() );
    }

    ObjectFileLink insertFileViewDto(String treePath, String checksum) {
        TreeDto treeDto = Objects.requireNonNull( tree.getOrigRecord( treePath ), "treePath not found" );
        UUID objectId = treeDto.getObjectId();
        UUID userId = treeDto.getUserId();
        FileViewDto.FileViewDtoBuilder toCreate = FileViewDto.builder().objectId( objectId )
                .userId( userId );
        FileViewDto createdRecord;
        if (treeDtoByChecksum.containsKey( checksum )) {
            // if duplicate objectPath <-> checksum link, table constraints prevent insertion
            // (unique composite key constraint on tree_join_file)
            UUID fileId = this.getOrigFileFor(checksum).getFileId();
            createdRecord = fileQueries.createLink( toCreate.fileId(fileId).size(fileSize++).build() )
                    .flatMap( rec -> fileQueries.fetchFileViewDto( rec.getObjectId(), rec.getFileId() ) )
                    .block();
        } else {
            // create new file with link
            toCreate.checksum( checksum )
                    .fileId( UUID.randomUUID() )
                    .size( fileSize++ );
            createdRecord = fileQueries.createFileWithLink( toCreate.build() ).block();
        }
        return new ObjectFileLink( treeDto, createdRecord );
    }

    // fileViewDto => newly created file or link
    // treeDto => object being linked to file
    void recordNewFileViewDto(ObjectFileLink link) {
        FileViewDto fileViewDto = link.fileViewDto();
        TreeDto treeDto = link.treeDto();
        String treePath = treeDto.getPath().data();
        String checksum = fileViewDto.getChecksum();
        NavigableSet<FileViewDto> fileRecSet = fileViewDtoByObjectPath.computeIfAbsent(
                treePath, k -> new TreeSet<FileViewDto>() );
        NavigableSet<TreeDto> treeRecSet = treeDtoByChecksum.computeIfAbsent(
                checksum, k -> new TreeSet<TreeDto>( ) );
        fileRecSet.add( fileViewDto );
        treeRecSet.add( treeDto );
        FileDto fileDto = fileViewToFile.convert(fileViewDto);
        if (!fileDto.equals(fileDtoByChecksum.computeIfAbsent(checksum,  k -> fileDto) ) ) {
            throw new IllegalStateException("Multiple inserts for same file checksum produced different file records");
        }
    }

    ObjectFileLink createLinkOrFile(CsvRecord csvRecord) {
        String treePath = csvRecord.treePath();
        String checksum = csvRecord.fileChecksum();
        return this.insertFileViewDto( treePath, checksum );
    }

    // using ObjectId in fileViewDto fetches obj path
    String fetchObjectPath(FileViewDto fileViewDto) {
        return Objects.requireNonNull( tree.fetchCurRecord( fileViewDto.getObjectId() ),
                        "TreeDto does not exist for objectId" )
                .getPath()
                .data();
    }

    record ObjectFileLink(TreeDto treeDto, FileViewDto fileViewDto) {
    }

    record CsvRecord(String treePath, String fileChecksum) {
    }

    static class TestFilesCsvParser {

        private TestFilesCsvParser() throws IllegalAccessException {
            throw new IllegalAccessException("Do not instantiate -- utility class");

        }
        static private final String COMMENT_REGEX = "^\s*#.*";
        static private final String DELIM_REGEX = "\s*,\s*";

        static Stream<CsvRecord> parse(@NonNull String csv) {
            return csv.lines().map( TestFilesCsvParser::splitLine )
                    .filter( split -> split.length == 2 )
                    .map( TestFilesCsvParser::toCsvRecord );
        }

        // returns String[0] for comments else String[2]
        private static String[] splitLine(String line) throws IllegalArgumentException {
            if (line.matches( COMMENT_REGEX ) || line.isBlank()) {
                // a comment;
                return new String[0];
            }
            String[] split = line.strip()
                    .split( DELIM_REGEX );
            if (split.length != 2) {
                throw new IllegalArgumentException( "Unable to parse line: " + line );
            }
            return split;
        }

        private static CsvRecord toCsvRecord(String[] split) {
            return new CsvRecord( split[0], split[1] );
        }
    }
}
